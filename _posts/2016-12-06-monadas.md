---
layout: post
title: Mónadas
authors:
  - M42
category: Programación
---

> A monad is a monoid in the category of endofunctors, what's the problem? 
>
> -- Apócrifo atribuido a **Philip Walder** en *A Brief, Incomplete, and Mostly Wrong 
>    History of programming languages*

## Prerequisitos

## Mónadas en Haskell

Podemos explicar las mónadas sin hacer ninguna referencia a la teoría de categorías.
Primero, explicando su motivación dentro de la programación funcional. Imaginemos
que necesitamos controlar cuando una función interna devuelve un error, o cambia un
estado que debe ser pasado al resto de funciones. 

## Motivación para las mónadas

### Calculando raíces cuadradas

Por ejemplo, supongamos que intentamos sacar raíces cuadradas en los reales usando
el [método de Newton](https://en.wikipedia.org/wiki/Integer_square_root#Algorithm). 
Si intentamos calcular $\sqrt{n}$, podemos tomar a cada paso la aproximación:

$$ x_{k+1} = \frac{1}{2}\left( x_k+\frac{n}{x_k} \right) $$

Y parar cuando estemos suficientemente cerca (más cerca que un ε dado):

$$ |x_{k+1} - x_k| < \varepsilon $$

Escribimos una implementación de ese concepto de convergencia para listas infinitas en Haskell
y del método de Newton, basado en la función `iterate`:

~~~ haskell
limit :: Float -> [Float] -> Float
limit epsilon (x:y:xs)
  | abs (x-y) < epsilon = y
  | otherwise           = limit epsilon (y:xs)

newtonsqrt :: Float -> Float -> Float
newtonsqrt n x = (x + n/x)/2

sqrt :: Float -> Float
sqrt 0 = 0
sqrt x = limit 0.03 (iterate (newtonsqrt x) x)
~~~

Ahora imaginemos que usamos esta raíz cuadrada recién definida para solucionar una ecuación
de segundo grado $x^2 + bx + c = 0$:

$$ x = \frac{-b \pm \sqrt{b^2 - 4c}}{2} $$

~~~ haskell
data QPol = QPol Float Float Float

instance Show QPol where
	show (Qpol a b c) = show a ++ "x² + " ++ show b ++ "x + " show c

solve :: QPol -> (Float,Float)
solve (QPol a b c) = (((-b) + sqrt(b*b-4*c*a))/(2*a), ((-b) - sqrt(b*b-4*c*a))/(2*a))
~~~

Y podemos comprobar que funciona:

~~~ bash
λ> pol = QPol 1 (-5) 6
λ> putStrLn $ "Las soluciones de " ++ show pol ++ " son " ++ solve pol
Las soluciones de 1.0x² + -5.0x + 6.0 son (3.0,2.0)
~~~

### Controlando los errores

Pero ¿qué ocurre cuando intentamos calcular la raíz cuadrada de un número no positivo?
Este método no la encuentra, por lo que debería devolver un error antes de intentar
empezar a calcularla. La solución obvia es reflejar este error con un `Maybe` en el
cálculo de la raíz cuadrada.

~~~ haskell
sqrt' :: Float -> Maybe Float
sqrt' x
  | x<0       = Nothing
  | x==0      = Just 0.0
  | otherwise = Just ( limit 0.03 (iterate (newtonsqrt x) x) )
~~~

Esto lo soluciona, pero nos crea un problema mayor. La función `solve` está usando la
raíz cuadrada y espera de ella que devuelva un número, no un posible error. Si queremos
conseguir que funcione con la nueva `sqrt'`, necesitaríamos implementar todas sus componentes
internas teniendo en cuenta ese error. Por ejemplo, deberíamos reescribir el `(+)`, para tener
en cuenta errores y propagarlos por todos los cálculos involucrando a `sqrt'`:

~~~ haskell
(+.) :: Maybe Float -> Maybe Float -> Maybe Float
(+.) Nothing _ = Nothing
(+.) _ Nothing = Nothing
(+.) (Just a) (Just b) = Just (a + b)
~~~

Pero esto es muy pesado para cada una de las operaciones. Y además obliga a cada una de nuestras
operaciones intermedias a ser conscientes de la posibilidad de error, lo que complicaría la escritura
de cada una de esas funciones. 

Una solución ligeramente mejor es la de abstraer este proceso de hacer a una función consciente
de la posibilidad de error en una función aparte y definir las demás en función suya:

~~~ haskell
errorAware :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
errorAware op Nothing _ = Nothing
errorAware op _ Nothing = Nothing
errorAware op (Just a) (Just b) = Just (op a b)

(+.), (*.) :: Maybe Float -> Maybe Float -> Maybe Float
(+.) = errorAware (+)
(*.) = errorAware (*)
~~~

Esto nos permite hacer cálculos con ellas:

~~~ haskell
λ> sqrt' (-3) +. Just 4
Nothing
λ> sqrt' 3 +. Just 4
Just 5.732143
~~~

### La mónada Maybe

Esta idea para simplificar el tratamiento de errores y otras similares es lo que nos va
a proporcionar la estructura de mónada. En Haskell, podemos definir una mónada como:

~~~ haskell
class Monad m where
  (>>=)  :: m a -> (a -> m b) -> m b
  return :: a -> m a
~~~

La idea intuitiva es que `(>>=)` nos permite tomar una función que puede devolver errores 
`(a -> Maybe b)` pero que no comprueba a la entrada si ha recibido un error; y la aplica sobre
una función que puede contener un error. La podríamos usar por ejemplo para componer varias
`sqrt'`, que era algo que hasta ahora no podíamos hacer sin tratar cada posible caso de error.
Y la función `return`, que en este caso es simplemente `Just`, nos permite considerar una constante
como un posible error. Podemos calcular fácilmente así $\sqrt\sqrt{3}$:

~~~ haskell
sqrt' (sqrt' 3)              -- ¡Error de tipos!
sqrt' 3 >>= sqrt'            -- Usando mónadas
Just   3 >>= sqrt' >>= sqrt' -- Usando Just
return 3 >>= sqrt' >>= sqrt' -- Equivalente a lo anterior
~~~

### Notación do
Las mónadas definen las funciones anteriores y muchas más que no vamos a tratar ahora mismo, pero
como resultado, nos acaban dando la **notación do**, que es la que podemos usar para acabar 
escribiendo nuestra función `solve` como:

~~~ haskell
solve' :: QPol -> Maybe (Float,Float)
solve' (QPol a b c) = do
  discriminant <- sqrt'(b*b - 4*c*a)
  return (((-b) + discriminant)/(2*a), ((-b) - discriminant)/(2*a))
~~~

En la primera línea tenemos en cuenta que la función `sqrt` puede producir error, y en la segunda
simplemente usamos el *posible* resultado de ella sin tener que preocuparnos por el resto de funciones.

## Mónadas en teoría de categorías
