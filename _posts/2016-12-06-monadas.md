---
layout: post
title: Mónadas
authors:
  - M42
category: Programación
---

> A monad is just a monoid in the category of endofunctors, what's the problem? 
>
> -- **Philip Walder** (apócrifo) en *[A Brief, Incomplete, and Mostly Wrong 
>    History of programming languages](http://james-iry.blogspot.com.es/2009/05/brief-incomplete-and-mostly-wrong.html)*

## Prerrequisitos

Este artículo requiere un conocimiento previo de Haskell, o al menos, de otro lenguaje de
programación funcional. Puedes consultar nuestra [introducción a Haskell](http://tux.ugr.es/dgiim/blog/2014/10/01/intro-haskell/) con recursos para 
iniciarte en el lenguaje.

Por otro lado, para la segunda parte del artículo es recomendable conocimiento previo sobre
teoría de categorías. Por suerte, no es necesaria para entender la primera parte del artículo,
donde podremos explicar las mónadas sin hacer ninguna referencia a la teoría de categorías.
También puedes consultar nuestros apuntes de 
[introducción a teoría de categorías](http://tux.ugr.es/dgiim/blog/2014/10/04/intro-categorias/).

## Motivación para las mónadas
### Mónadas en Haskell
Empezamos explicando la motivación de las mónadas dentro de la programación funcional. Imaginemos
que necesitamos controlar cuando una función interna devuelve un error, o cambia un
estado que debe ser pasado al resto de funciones. Una solución sería modificar cada una de las
funciones que usamos para que tenga en cuenta ese estado, pero esto añadiría mucha complejidad
innecesaria a nuestro código.

El siguiente ejemplo está inspirado en los ejemplos del artículo:

 - [Monads for functional programming](http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf) - *Philip Wadler*

### Calculando raíces cuadradas

Por ejemplo, supongamos que intentamos sacar raíces cuadradas en los reales usando
el [método de Newton](https://en.wikipedia.org/wiki/Integer_square_root#Algorithm). 
Si intentamos calcular $\sqrt{n}$, podemos tomar a cada paso la aproximación:

$$ x_{k+1} = \frac{1}{2}\left( x_k+\frac{n}{x_k} \right) $$

Y parar cuando estemos suficientemente cerca (más cerca que un ε dado):

$$ |x_{k+1} - x_k| < \varepsilon $$

Escribimos una implementación de ese concepto de convergencia para listas infinitas en Haskell
y del método de Newton, basado en la función `iterate`:

~~~ haskell
limit :: Float -> [Float] -> Float
limit epsilon (x:y:xs)
  | abs (x-y) < epsilon = y
  | otherwise           = limit epsilon (y:xs)

newtonsqrt :: Float -> Float -> Float
newtonsqrt n x = (x + n/x)/2

sqroot :: Float -> Float
sqroot 0 = 0
sqroot x = limit 0.03 (iterate (newtonsqrt x) x)
~~~

Ahora imaginemos que usamos esta raíz cuadrada recién definida para solucionar una ecuación
de segundo grado $x^2 + bx + c = 0$:

$$ x = \frac{-b \pm \sqrt{b^2 - 4c}}{2} $$

~~~ haskell
data QPol = QPol Float Float Float

instance Show QPol where
	show (Qpol a b c) = show a ++ "x² + " ++ show b ++ "x + " show c

solve :: QPol -> (Float,Float)
solve (QPol a b c) = (((-b) + sqroot(b*b-4*c*a))/(2*a), ((-b) - sqroot(b*b-4*c*a))/(2*a))
~~~

Y podemos comprobar que funciona:

~~~ bash
λ> pol = QPol 1 (-5) 6
λ> putStrLn $ "Las soluciones de " ++ show pol ++ " son " ++ solve pol
Las soluciones de 1.0x² + -5.0x + 6.0 son (3.0,2.0)
~~~

### Controlando los errores

Pero ¿qué ocurre cuando intentamos calcular la raíz cuadrada de un número no positivo?
Este método no la encuentra, por lo que debería devolver un error antes de intentar
empezar a calcularla. La solución obvia es reflejar este error con un `Maybe` en el
cálculo de la raíz cuadrada.

~~~ haskell
sqroot' :: Float -> Maybe Float
sqroot' x
  | x<0       = Nothing
  | x==0      = Just 0.0
  | otherwise = Just ( limit 0.03 (iterate (newtonsqrt x) x) )
~~~

Esto lo soluciona, pero nos crea un problema mayor. La función `solve` está usando la
raíz cuadrada y espera de ella que devuelva un número, no un posible error. Si queremos
conseguir que funcione con la nueva `sqroot'`, necesitaríamos implementar todas sus componentes
internas teniendo en cuenta ese error. Por ejemplo, deberíamos reescribir el `(+)`, para tener
en cuenta errores y propagarlos por todos los cálculos involucrando a `sqroot'`:

~~~ haskell
(+.) :: Maybe Float -> Maybe Float -> Maybe Float
(+.) Nothing _ = Nothing
(+.) _ Nothing = Nothing
(+.) (Just a) (Just b) = Just (a + b)
~~~

Pero esto es muy pesado para cada una de las operaciones. Y además obliga a cada una de nuestras
operaciones intermedias a ser conscientes de la posibilidad de error, lo que complicaría la escritura
de cada una de esas funciones. 

Una solución ligeramente mejor es la de abstraer este proceso de hacer a una función consciente
de la posibilidad de error en una función aparte y definir las demás en función suya:

~~~ haskell
errorAware :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
errorAware op Nothing _ = Nothing
errorAware op _ Nothing = Nothing
errorAware op (Just a) (Just b) = Just (op a b)

(+.), (*.) :: Maybe Float -> Maybe Float -> Maybe Float
(+.) = errorAware (+)
(*.) = errorAware (*)
~~~

Esto nos permite hacer cálculos con ellas:

~~~ haskell
λ> sqroot' (-3) +. Just 4
Nothing
λ> sqroot' 3 +. Just 4
Just 5.732143
~~~

### La mónada Maybe

Esta idea para simplificar el tratamiento de errores y otras similares es lo que nos va
a proporcionar la estructura de mónada. En Haskell, podemos definir una mónada como:

~~~ haskell
class Monad m where
  (>>=)  :: m a -> (a -> m b) -> m b
  return :: a -> m a
~~~

La idea intuitiva es que `(>>=)` nos permite tomar una función que puede devolver errores 
`(a -> Maybe b)` pero que no comprueba a la entrada si ha recibido un error; y la aplica sobre
una función que puede contener un error. La podríamos usar por ejemplo para componer varias
`sqroot'`, que era algo que hasta ahora no podíamos hacer sin tratar cada posible caso de error.
Y la función `return`, que en este caso es simplemente `Just`, nos permite considerar una constante
como un posible error. Podemos calcular fácilmente así $\sqrt\sqrt{3}$:

~~~ haskell
sqroot' (sqroot' 3)              -- ¡Error de tipos!
sqroot' 3 >>= sqroot'            -- Usando mónadas
Just   3 >>= sqroot' >>= sqroot' -- Usando Just
return 3 >>= sqroot' >>= sqroot' -- Equivalente a lo anterior
~~~

### Notación do
Las mónadas definen las funciones anteriores y muchas más que no vamos a tratar ahora mismo, pero
como resultado, nos acaban dando la **notación do**, que es la que podemos usar para acabar 
escribiendo nuestra función `solve` como:

~~~ haskell
solve :: QPol -> Maybe (Float,Float)
solve (QPol a b c) = do
  discriminant <- sqroot' (b*b - 4*c*a)
  return (((-b) + discriminant)/(2*a), ((-b) - discriminant)/(2*a))
~~~

En la primera línea tenemos en cuenta que la función `sqroot` puede producir error, y en la segunda
simplemente usamos el *posible* resultado de ella sin tener que preocuparnos por el resto de funciones.

## Mónadas en teoría de categorías
Para entender cómo funcionan las 
[mónadas](https://es.wikipedia.org/wiki/M%C3%B3nada_(teor%C3%ADa_de_categor%C3%ADas)) 
en teoría de categorías tenemos que entender dos conceptos: los 
*productos en una [categoría monoidal](https://es.wikipedia.org/wiki/Categor%C3%ADa_monoidal)* y 
*los endofuntores de una categoría*. La unión de ambos conceptos es lo que nos dará las mónadas 
como una construcción en teoría de categorías.

### Categorías monoidales
Simplificando, una categoría monoidal es aquella donde, dados dos objetos $A,B$, tenemos
un objeto *"producto tensor"* de ambos, $A \otimes B$, donde además existe un objeto identidad $I$
cumpliendo propiedades como:

	- $A \otimes B \cong B \otimes A$
	- $A \otimes (B \otimes C) \cong (A \otimes B) \otimes C$
	- $A \otimes I \cong A$

### Ejemplos de categorías monoidales
Los **conjuntos** con el producto cartesiano y el conjunto de un elemento forman ya una categoría
monoidal. Puede comprobarse sobre ellos que existen los isomorfismos:

	- $A \times B \cong B \times A$
	- $A \times (B \times C) \cong (A \times B) \times C$
	- $A \times \{\bullet\} \cong A$

Pero además, podemos darles *otra* estructura de categoría monoidal, esta vez con la 
[unión disjunta](https://es.wikipedia.org/wiki/Uni%C3%B3n_disjunta) y el conjunto vacío:

	- $A \sqcup B \cong B \sqcup A$
	- $A \sqcup (B \sqcup C) \cong (A \sqcup B) \sqcup C$
	- $A \sqcup \varnothing \cong A$

En general, todas las categorías con productos finitos son categorías monoidales con el producto
categórico y el objeto terminal como unidad. Todas las categorías con coproductos finitos son 
categorías monoidales con el coproducto categórico y el objeto inicial como unidad.

Otro ejemplo distinto lo forman los **espacios vectoriales** sobre un cuerpo $K$ con el producto tensor
y el propio cuerpo sirviendo como unidad; o los **grupos abelianos** con el producto tensor y 
$\mathbb{Z}$ siendo la unidad.

### Objetos monoide
Un objeto $A$ de una categoría monoidal es objeto monoide cuando puedo definir un morfismo desde
el objeto identidad hacia él y un morfismo desde el producto tensor $A \otimes A$ hacia él. Es decir,
hay un morfismo *cero*:

$$ I \overset{0}\longrightarrow A $$

Y un morfismo *multiplicación*:

$$ A \otimes A \overset{\mu}\longrightarrow A$$

Cumpliendo ciertas propiedades similares a las que exigimos a un monoide. De hecho, un objeto monoide
en la categoría de los conjuntos con el producto cartesiano es simplemente un **monoide** normal y 
corriente.

### Categorías de endofuntores
El ejemplo que nos interesa ahora, sin embargo, es el de los **endofuntores** de una categoría.
Un **funtor**, de forma simplificada, es una *aplicación entre categorías*; que lleva objetos en
objetos y morfismos en morfismos, respetando además el punto de inicio y fin de cada morfismo.

Si consideramos los funtores de una categoría a sí misma, tenemos los **endofuntores** de la
categoría. Y entre ellos existen transformaciones naturales que actúan como morfismos en el sentido
de que se componen para dar otras transformaciones naturales. Teniendo unos objetos (los endofuntores),
y unos morfismos (las transformaciones naturales), tenemos una categoría. Nótese que hemos abstraído
mucho, estamos trabajando con una categoría en la que cada objeto es en sí mismo un endofuntor y
cada morfismo es toda una transformación natural entre dos funtores.

Esta es además una categoría monoidal. El producto tensor de esta categoría monoidal será la
composición $\circ$, y el objeto identidad el endofuntor identidad, que actúa dejando fijo cada objeto
y cada morfismo.

### Mónadas
Pues bien, una mónada es un objeto monoide en la categoría de los endofuntores con la composición
como producto tensor. Esto quiere decir que es un endofuntor $F$ con transformaciones naturales:

$$ F \circ F \Rightarrow F $$

$$ I \Rightarrow F$$

Como una transformación natural nos da un morfismo por cada objeto en el que se aplica el funtor,
lo que tenemos son familias de morfismos:

$$ F(F(X)) \overset{\mu_x}\longrightarrow F(X) $$

$$X \overset{r_x}\longrightarrow F(X) $$

### Una categoría para la programación funcional
Algunos sistemas de tipos, con las funciones entre ellos `A -> B` como morfismos, forman una 
categoría. No es el caso de Haskell, en el que, por varios motivos, sus tipos no forman una
categoría[^hask-not-a-category]; pero las construcciones con inspiración en la teoría de categorías
toman el nombre de sus homólogas.[^hask-matters]

El primer ejemplo de esto son los **funtores**. En Haskell, un funtor se define como:

~~~ haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b
~~~

Es decir un funtor toma un tipo `a` (un objeto de la categoría), y nos devuelve otro tipo `f a` (otro 
objeto de la *misma* categoría). Por otro lado, el funtor toma un morfismo `a -> b` y nos devuelve 
otro morfismo `f a -> f b`. Es decir, los funtores de la programación funcional son **endofuntores en
la categoría de los tipos**, siempre que conserven ciertas reglas que tienen su reflejo en las
reglas de funtores en Haskell.

### Objeto monoide
Entonces, si los funtores `f :: * -> *` son endofuntores en alguna categoría, tiene sentido
cuestionarse cuáles de ellos son monoides. Esto, junto con ciertas 
restricciones que se le imponen como leyes a las mónadas, equivale a decir que existen los
morfismos dados por las transformaciones naturales que pedíamos antes, es decir, deben
existir morfismos de tipos `a -> m a` y `m (m a) -> m a`:

~~~ haskell
return :: a -> m a
join :: m (m a) -> m a
~~~

Así, a cualquier funtor que tiene estos dos morfismos, además del `fmap` que tenía por ser funtor,
lo llamamos **mónada**. Nótese que `>>=` puede implementarse desde `join` y viceversa, como:

~~~ haskell
(>>=) :: m a -> (a -> m b) -> m b
(>>=) x f = join (fmap f a)

join :: m (m a) -> m a
join x = x >>= id
~~~

Tenemos entonces dos definiciones equivalentes de lo que es una mónada. Una desde la teoría de
categorías y otra desde la teoría de tipos y los lenguajes de programación funcional.

## Referencias
[^hask-not-a-category]: [Hask is not a category - Andrej Bauer](http://math.andrej.com/2016/08/06/hask-is-not-a-category/)
[^hask-matters]: [Does it matter if Hask is (not) a category?](https://ro-che.info/articles/2016-08-07-hask-category)
